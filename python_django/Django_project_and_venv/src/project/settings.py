"""
Django settings for project project.

Generated by 'django-admin startproject' using Django 3.1.7.

For more information on this file, see
https://docs.djangoproject.com/en/3.1/topics/settings/

For the full list of settings and their values, see
https://docs.djangoproject.com/en/3.1/ref/settings/
"""

import gunicorn
import os
import logging

from pathlib import Path

# Build paths inside the project like this: BASE_DIR / 'subdir'.
BASE_DIR = Path(__file__).resolve().parent.parent


# for django ORM to work in jupyter
# https://stackoverflow.com/a/62119475
os.environ["DJANGO_ALLOW_ASYNC_UNSAFE"] = "true"

# During launch jupyter notebook server will show the address and port and token
# that you will need to use as URL to access it.

NOTEBOOK_ARGUMENTS = [
    '--ip', '0.0.0.0',
    '--port', '8888'
]


# Quick-start development settings - unsuitable for production
# See https://docs.djangoproject.com/en/3.1/howto/deployment/checklist/

# SECURITY WARNING: keep the secret key used in production secret!
SECRET_KEY = '5=4=tld0@*kc2pm$4)^p8ruq)49yrj5h5)+v#10-(=unp8)uca'

# SECURITY WARNING: don't run with debug turned on in production!
if os.environ['DEBUG'] == "1":
    DEBUG = True
else:
    DEBUG = False

ALLOWED_HOSTS = ['*']

#https://learndjango.com/tutorials/django-password-reset-tutorial

EMAIL_BACKEND = 'django.core.mail.backends.filebased.EmailBackend'
EMAIL_FILE_PATH = os.path.join(BASE_DIR,'sent_emails')


# Application definition

INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',

    # new apps created
    'users',

    # third party installed packages
    'django_extensions',
    'bootstrap4',
]





MIDDLEWARE = [
    'django.middleware.security.SecurityMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.common.CommonMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
]

if os.environ['SQLPRINT'] == "1":
    MIDDLEWARE.insert(0,'project.custom_middleware.request_logging.middleware.LoggingMiddleware')   #<--  installed django-request-logging https://github.com/Rhumbix/django-request-logging
    MIDDLEWARE.insert(0,'project.custom_middleware.request_exposure.RequestExposerMiddleware') #<--- will set the exposed_request  variable, initiall define it as None


#<--  installed django-request-logging https://github.com/Rhumbix/django-request-logging
REQUEST_LOGGING_DATA_LOG_LEVEL=logging.CRITICAL
REQUEST_LOGGING_HTTP_4XX_LOG_LEVEL=logging.CRITICAL
REQUEST_LOGGING_MAX_BODY_LENGTH = 1000
REQUEST_LOGGING_ENABLE_COLORIZE = True


ROOT_URLCONF = 'project.urls'

TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [os.path.join(BASE_DIR, 'templates')],
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.debug',
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
            ],
        },
    },
]

WSGI_APPLICATION = 'project.wsgi.application'


# Database
# https://docs.djangoproject.com/en/3.1/ref/settings/#databases

DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3',
        'NAME': BASE_DIR / 'db.sqlite3',
    }
}


AUTH_USER_MODEL = 'users.User'

# Password validation
# https://docs.djangoproject.com/en/3.1/ref/settings/#auth-password-validators

AUTH_PASSWORD_VALIDATORS = [
    {
        'NAME': 'django.contrib.auth.password_validation.UserAttributeSimilarityValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.CommonPasswordValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.NumericPasswordValidator',
    },
]


# Internationalization
# https://docs.djangoproject.com/en/3.1/topics/i18n/

LANGUAGE_CODE = 'en-us'

TIME_ZONE = 'UTC'

USE_I18N = True

USE_L10N = True

USE_TZ = True


# Static files (CSS, JavaScript, Images)
# https://docs.djangoproject.com/en/3.1/howto/static-files/

STATIC_ROOT = os.path.join(BASE_DIR, 'staticfiles')
STATIC_URL = '/static/'
STATICFILES_DIRS = (os.path.join(BASE_DIR, 'static'),)


LOGIN_URL = 'login'
LOGIN_REDIRECT_URL = 'dashboard'
LOGOUT_REDIRECT_URL = 'login'

# django_heroku.settings(locals())


import os
import logging
import traceback


#######################################################
# Logging objects, sql, traceback and strings
#######################################################

import logging
import traceback

from datetime import datetime
from pytz import timezone

exposed_request=None


## def timetz(*args):
##     tz = timezone('UTC')
##     return datetime.now(tz).timetuple()
## 
##  # UTC, Asia/Shanghai, Europe/Berlin
## 
## logging.Formatter.converter = timetz


# Verbose formatter to be used for the handler used in logging "custom_string"
class VerFormatter(logging.Formatter):
    def format(self, record):
        ## We want to show some code lines while logging. So that its eays to know 
        #create a list of all the linenumber: lines 
        lines=[]
        with open(record.pathname) as src:
            for index, line in enumerate(src.readlines(), start=1):
                if index == record.lineno:
                    lines.append('{:4d}***: {}'.format(index, line))
                else:
                    lines.append('{:7d}: {}'.format(index, line))
        # select +/-3 lines from the current line
        start=(record.lineno -1) - 5
        end=(record.lineno -1) + 5
        if record.lineno == len(lines):
            end = record.lineno-1
        if end > len(lines)-1:
            end = len(lines)-1
        if record.lineno -1 == 0:
            start = 0
        if start < 0:
            start = 0
        code = ''.join(lines[start:end+1]) #lines[start:length]

        # colorize the code
        import pygments
        from pygments.lexers.python import Python3Lexer
        from pygments.formatters import TerminalTrueColorFormatter
        # windows terminal has no colors
        #code = pygments.highlight(
        #    code,
        #    Python3Lexer(),
        #    #TerminalTrueColorFormatter(style='monokai') #use for terminal
        #    TerminalTrueColorFormatter() #use for jupyter notebook
        #)

        #add new attributes to record which will be used later
        # we also want to have the url requested and its method
        if exposed_request is not None:
            record.absolute_path = exposed_request.build_absolute_uri()
            record.method = exposed_request.method
        else:
            record.absolute_path = "NONE_NO_REQUEST_ABS_PATH        "
            record.method = "NONE_NO_REQUEST_METHOD"
        record.codelines = code
        record.topline = "--------------------------------------------------------------------------------------------------------------"
        record.botline = "--------------------------------------------------------------------------------------------------------------"
        return super(VerFormatter, self).format(record)

# Verbose formatter to be used django-request
class VerFormatter2(logging.Formatter):
    def format(self, record):
        #add new attributes to record which will be used later
        # we also want to have the url requested and its method
        if exposed_request is not None:
            record.absolute_path = exposed_request.build_absolute_uri()
            record.method = exposed_request.method
        else:
            record.absolute_path = "NONE_NO_REQUEST_ABS_PATH        "
            record.method = "NONE_NO_REQUEST_METHOD"
        record.topline = "--------------------------------------------------------------------------------------------------------------"
        record.botline = "^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        return super(VerFormatter2, self).format(record)


# SQL formatter to be used for the handler used in logging "django.db.backends"
class SQLFormatter(logging.Formatter):
    def format(self, record):

        # Check if Pygments is available for coloring 
        try:
            import pygments
            from pygments.lexers import SqlLexer
            from pygments.formatters import TerminalTrueColorFormatter
        except ImportError:
            pygments = None

        # Check if sqlparse is available for indentation
        try:
            import sqlparse
        except ImportError:
            sqlparse = None

        # Remove leading and trailing whitespaces
        sql = record.sql.strip()

        if sqlparse:
            # Indent the SQL query
            sql = sqlparse.format(sql, reindent=True)
# windows console dont support colors
        if pygments:
            # Highlight the SQL query
            sql = pygments.highlight(
                sql,
                SqlLexer(),
                TerminalTrueColorFormatter()
                #TerminalTrueColorFormatter(style='monokai')
            )

        # Set the record's statement to the formatted query
        record.statement = sql
        if 'duration' in record.__dict__:
          pass
        else:
          record.duration = "NA"
        return super(SQLFormatter, self).format(record)



### Change this to closed when there are too many queries going on.and use 
### logger_database.filters[0].open() INDSIDE THE views function not on the top
LoggerGate_Default_State="open"  # use this if we want to see all the sql
#LoggerGate_Default_State="closed"  # use this if we want dont want to see all the sql


# Filter class to stop or start logging for "django.db.backends"
class LoggerGate:
    def __init__(self, state=LoggerGate_Default_State):
        # We found that the settings.py runs twice and the filters are created twice. So we have to keep only one. So we delete all the previous filters before we create the new one
        import logging
        logger_database = logging.getLogger("django.db.backends")
        try:
            for filter in logger_database.filters:
                logger_database.removeFilter(filter)
        except Exception as e:
            pass
        self.state = state

    def open(self):
        self.state = 'open'

    def close(self):
        self.state = 'closed'

    def filter(self, record):
        """
        Determine if the specified record is to be logged.

        Is the specified record to be logged? Returns 0/False for no, nonzero/True for
        yes. If deemed appropriate, the record may be modified in-place.
        """
        if self.state == 'open':
            print('\n')
            print('##############################################################################################################')
            print('SQL QUERIED')
            if exposed_request is not None:
                print("PATH: "+exposed_request.build_absolute_uri())
                print("METHOD: "+exposed_request.method)
               #print(pp_odir(exposed_request,traceback.format_stack(limit=4)))
            print('##############################################################################################################')
            # uncomment when to see the traceback
            print('\n')
            print(pp_traceback(traceback.format_stack(limit=20)))
            print('\n')     
        return self.state == 'open'

if os.environ['SQLPRINT'] == "1":
    server_format = "\n\n$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$\n############################################################################################\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))\n(((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((\n&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&\n"
else:
    server_format = ""


print(server_format)

LOGGING = {
    'version': 1,
    'disable_existing_loggers': False,
    'formatters': {
        'sql': {
            '()': SQLFormatter,
            'format': '[%(duration).3f]\n%(statement)s',
        },
        'verbose': {
            '()': VerFormatter,
            'format': '%(topline)s\n%(asctime)s\nXXX%(levelname)sXXX %(funcName)s() %(pathname)s[:%(lineno)s] %(name)s\n\%(method)s -- %(absolute_path)s\n%(topline)s\n\n%(codelines)s\n\n%(message)s\n\n%(codelines)s',
            #'datefmt': "[%d/%b/%Y %H:%M:%S %p %Z]"
        },
        'verbose2': {
            '()': VerFormatter2,
            'format': '%(topline)s\n%(asctime)s--XXX%(levelname)sXXX %(funcName)s() %(pathname)s[:%(lineno)s] %(name)s\n\%(method)s -- %(absolute_path)s\n%(botline)s\n%(message)s',
            #'datefmt': "[%d/%b/%Y %H:%M:%S %p %Z]"
        },
        'django.server': {
            '()': 'django.utils.log.ServerFormatter',
            'format': '[{asctime}] {message}'+server_format,
            'datefmt' : '%Y-%m-%d %H:%M:%S',
            'style': '{',
            }
    },
    'handlers': {
        'console': {
            'level': 'DEBUG',
            'formatter': 'verbose',
            'class': 'logging.StreamHandler',
        },
        'console2': {
            'level': 'DEBUG',
            'formatter': 'verbose2',
            'class': 'logging.StreamHandler',
        },
        'sql': {
            'class': 'logging.StreamHandler',
            'formatter': 'sql',
            'level': 'DEBUG',
        },
        'django.server': {
            'class': 'logging.StreamHandler',
            'formatter': 'django.server',
        },
    },
    'filters': {
        'myfilter': {
            '()': LoggerGate,
        }
    },
    'loggers': {
        'django.db.backends': {
            'handlers': ['sql'],
            'level': 'DEBUG' if (os.environ['SQLPRINT'] == "1") else 'INFO',
            'propagate': False,
            'filters': ['myfilter']
        },
#        'django.db.backends.schema': {
#            'handlers': ['console'],
#            'level': 'DEBUG',
#            'propagate': False,
#        },
        'custom_string': {
            'level': 'DEBUG' if DEBUG else 'INFO',
            'handlers': ['console'],
            'propagate': False,
        },
        'django.server':{
            'handlers': ['django.server'],
            'propagate': False,
        },
        # added from django-request-logging
        'django.request': {
            'handlers': ['console2'],
            'level': logging.CRITICAL if DEBUG else 'INFO',  # change debug level as appropiate
            'propagate': False,
        },

    }
}

# added from django-LoggingMiddleware
REQUEST_LOGGING_DATA_LOG_LEVEL=logging.CRITICAL
REQUEST_LOGGING_HTTP_4XX_LOG_LEVEL=logging.CRITICAL
REQUEST_LOGGING_MAX_BODY_LENGTH = 1000


#######################################################
# Pretty printing object and sql by various means
#######################################################

# This function is used to pretty print anything as a str.
# Eg: 
### USING WHILE LOGGING
###    ## LOGGING
###    import logging
###    import traceback
###    logger_custom_string = logging.getLogger("custom_string")
###    from basic_django import settings as settings_basic_django
###    #usage1: To show anything as string
###    #logger_custom_string.debug(settings_basic_django.anything("Hare Krishna",traceback.format_stack(limit=5)))
###
### USING WITH PRINT
###    ## LOGGING
###    import logging
###    import traceback
###    from basic_django import settings as settings_basic_django
###    print(settings_basic_django.anything("Hare Krishna",traceback.format_stack(limit=5)))
def anything(var,trace):
    trace_hightligh = pp_traceback(trace)
    str3 = '\n\n'.join([str(var), trace_hightligh])
    return str3

# The below function converts any byte string keys into string
#we found that if key is byte string then json.dumps will throw error So we have to convert the dict
# recursive key as string conversion for byte keys
#https://stackoverflow.com/a/57014404/2897115
def keys_string(d):
    rval = {}

    # Sometimes the object is not a dict it can be list and also. So 
    # Eg:
    ## '_preconf_set_by_auto': {'result_backend', 'broker_url'}
    ## the above will raise error: AttributeError: 'str' object has no attribute 'items'
    ## list = [1,3,4] To declare a tuple, we use brackets.
    ## tuples = (1, 2, "a") To declare a tuple, we use parentheses.
    ## sets = {1,2,3} declare a set. Use curly braces 
    # So we check whether its a dict and then its a tuple,list,set
    if not isinstance(d, dict):
        if isinstance(d,(tuple,list,set)):
            v = [keys_string(x) for x in d]
            return v
        else:
            return d

    # we have to store the keys in a list else some objects give dictionary
    # changed size during iteration error
    # https://stackoverflow.com/questions/59662479/python-error-dictionary-changed-size-during-iteration-when-trying-to-iterate
    keys = list(d.keys())
    for k in keys:
        v = d[k]
        if isinstance(k,bytes):
            k = k.decode()
        if isinstance(v,dict):
            v = keys_string(v)
        elif isinstance(v,(tuple,list,set)):
            v = [keys_string(x) for x in v]
        rval[k] = v
    return rval


# in json_dumps we can pass a default function
def json_dumps_default(obj):
    repr_obj = repr(obj)
    str_obj = str(obj)

    if repr_obj == str_obj:
        return repr_obj
    else:
        return repr_obj,f"STR: {str_obj}"

# If the obj is not dict.tuple,list,set then we categorize the dir(obj)
def pp_odir_getobject(obj):
    if isinstance(obj,dict):
        return keys_string(obj)
    if isinstance(obj,(tuple,list,set)):
        return keys_string(obj)

    #c_dict = {k: getattr(obj, k) for k in dir(obj)} # this gives all the properties listed using dir(c)

    # we are not using the above is because if there are except it stops
    c_dict = {
                '00_METHODS********************************************************************************':{},
                "01_UNDESCORE******************************************************************************":{},
                "02_OTHERS*********************************************************************************":{},
                "03_EXCEPTIONS*****************************************************************************":{},
                }
    for key in dir(obj):
        try:
            attr_obj = getattr(obj, key)
            if callable(attr_obj):
            #if inspect.ismethod(attr_obj):
                c_dict['00_METHODS********************************************************************************'][key] = attr_obj
            else:
                if key.startswith("_"):
                    c_dict['01_UNDESCORE******************************************************************************'][key] = attr_obj
                else:
                    c_dict['02_OTHERS*********************************************************************************'][key] = attr_obj
        except Exception as x:
            c_dict['03_EXCEPTIONS*****************************************************************************'][key] = x
    return keys_string(c_dict)


# pretty print using dir(obj) and then its properties and also the traceback
def pp_odir(obj,trace):

    ##  json.dumps(queryset) in Jupyter runs lot of sqls if the object is query set so we want to avoid that. It work fine with views.py
    ## .So we want to stop logging before json_str and continue back with its state after
    import logging
    logger_database = logging.getLogger("django.db.backends")
    try:
        log_filt_state=logger_database.filters[0].state
        logger_database.filters[0].close()
    except:
        pass

    # we have to do two things 1) is to convert any byte strings to keys and also segrate into methods,underscore and other and exceptions
    c_dict_flattened = pp_odir_getobject(obj)

    import json
    from pygments import highlight
    from pygments.lexers import JsonLexer
    from pygments.formatters import TerminalTrueColorFormatter
    #Before passing the dict we want to avoid any byte string keys so keys_string(c_dict)
    json_str=json.dumps(c_dict_flattened, indent=4, sort_keys=True, default=json_dumps_default)

    try:
        # based on the logging status continue after    
        if log_filt_state == 'open':
            logger_database.filters[0].open()
    except:
        pass

    #highlight_obj = highlight(json_str, JsonLexer(), TerminalTrueColorFormatter(style='monokai'))
    highlight_obj = json_str
    trace_hightligh = pp_traceback(trace)
    str3 = '\n\n'.join([highlight_obj, trace_hightligh])
    return str3


def pp_sql_sql(sql):
    import sqlparse
    import pygments
    from pygments.lexers import SqlLexer
    from pygments.formatters import TerminalTrueColorFormatter
    # format using sqlparser
    sql = sqlparse.format(sql, reindent=True)
    # color it using pygments
    sql = pygments.highlight(sql,SqlLexer(),TerminalTrueColorFormatter(style='solarized-dark'))
    return sql

# pretty print sql query from queryset using mogrify(available only for Psycopg)
# Advantage: It does not execute any sql to get the sql
def pp_sql_query_pg(qs):
    from django.db import connections
    # Get a cursor tied to the database of queryset
    cursor = connections[qs.db].cursor()

    # Get the query SQL and parameters to be passed into psycopg2
    query, params = qs.query.sql_with_params()

    # use mogrify: Return a query string after arguments binding. The string returned is exactly the one that would be sent to the database running the execute() method or similar.
    # mogrify is not a method defined by the Python DB API, but instead an add-on of the Psycopg driver. It does not exist for MySql
    sql = cursor.mogrify(query, params)

    # Then format it using sqlparser and color it using pygment
    import sqlparse
    import pygments
    from pygments.lexers import SqlLexer
    from pygments.formatters import TerminalTrueColorFormatter
    # format using sqlparser
    sql = sqlparse.format(sql, reindent=True)
    # color it using pygments
    sql = pygments.highlight(sql,SqlLexer(),TerminalTrueColorFormatter(style='solarized-dark'))
    return sql

#pretty print sql query from queryset if Psycopg is not installed (or using database other then postgresql)
# Disadvantage: runs an additional sql query with EXPLAIN
def pp_sql_query_any(qs):
    from django.db import connections
    # Get a cursor tied to the database of queryset
    cursor = connections[qs.db].cursor()

    # Get the query SQL and parameters to be passed into psycopg2
    query, params = qs.query.sql_with_params()

    # Execute the sql
    cursor.execute('EXPLAIN ' + query, params)

    # then get the last executed sql query
    sql = str(cursor.db.ops.last_executed_query(cursor, query, params))

    # Just for confirmation
    assert sql.startswith('EXPLAIN ')

    # Then format it using sqlparser and color it using pygment
    import sqlparse
    import pygments
    from pygments.lexers import SqlLexer
    from pygments.formatters import TerminalTrueColorFormatter
    # format using sqlparser
    sql = sqlparse.format(sql, reindent=True)
    # color it using pygments
    sql = pygments.highlight(sql,SqlLexer(),TerminalTrueColorFormatter(style='solarized-dark'))
    return sql


#######################################################
# Pretty printing traceback format_stack###
#######################################################

def pp_traceback(traceback_format_stack):
    import pygments
    from pygments.lexers import Python3TracebackLexer
    from pygments.formatters import TerminalTrueColorFormatter
    traceback_string = ''.join(traceback_format_stack)
    #traceback_color = pygments.highlight(traceback_string,Python3TracebackLexer(),TerminalTrueColorFormatter(style='trac')) # trac or rainbow_dash
    traceback_color = traceback_string
    return traceback_color



###    ###############################
###    #USAGGE################
###    ## LOGGING
###    import logging
###    import traceback
###    logger_custom_string = logging.getLogger("custom_string")
###    from basic_django import settings as settings_basic_django
###    #usage1: To show anything as string
###    #logger_custom_string.debug(settings_basic_django.anything("Hare Krishna",traceback.format_stack(limit=5)))
###    #usage2: to show dict or obj
###    #logger_custom_string.debug(settings_basic_django.pp_odir(locals(),traceback.format_stack(limit=5)))
###    #logger_custom_string.debug(settings_basic_django.pp_odir(obj,traceback.format_stack(limit=5)))  # This will pretty print all the properties from dir(obj)
###    #sql = str(user_set.query)
###    #sql = user_set.query.__str_s_()
###    ##logger_custom_string.debug(settings_basic_django.pp_sql_sql(sql)) # pretty print the sql obtained from the .query
###    ##logger_custom_string.debug(settings_basic_django.pp_sql_query_pg(user_set)) # pretty print the sql using mogrify only possible with Psycopg
###    ##logger_custom_string.debug(settings_basic_django.pp_sql_query_any(user_set)) # pretty print the sql using EXPLAIN. But runs extra sql
###    #import traceback
###    ##logger_custom_string.debug(settings_basic_django.pp_traceback(traceback.format_stack(limit=5))) #test traceback
###    logger_database = logging.getLogger("django.db.backends")
###    #usage:  (USE THIS INDSIDE THE views function not on the top.)
###    #logger_database.filters[0].open()
###    #logger_database.filters[0].close()

#######################################################
# Get ip address
#######################################################

def get_client_ip(request):
    x_forwarded_for = request.META.get('HTTP_X_FORWARDED_FOR')
    if x_forwarded_for:
        ip = x_forwarded_for.split(',')[0]
    else:
        ip = request.META.get('REMOTE_ADDR')
    return ip